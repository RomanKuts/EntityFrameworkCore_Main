//using System;
//using System.Collections.Generic;
//using System.ComponentModel.DataAnnotations;
//using System.Linq;
//using Microsoft.EntityFrameworkCore;

//namespace Test_EF_core
//{
//    // Якщо ми використовуємо підхід Code First - то класи моделей співставляються з таблицями з допомогою ряду правил Entity Framework
//    // Проте інколи необхідно змінити і перевизначити логіку цих правил. Для цього використовується Fluen API та анотація даних

//    // РОЗГЛЯНЕМО ДЕТАЛЬНІШЕ - ЩО ЯВЛЯЄ СОБОЮ Fluent API

//    // Fluent API - в загальному являє собою набір методів, які визначаються співставленням між класами і їх властивостями та таблицями і їх колонками
//    // Як правило, функціонал Fluent API задіюється при перевизначенні методу OnModelCreating

//    // В якості експерементальної моделі візьмемо наступну модель
//    public class Phone
//    {
//        public int Ident { get; set; }
//        public string Name { get; set; }
//        public int Discount { get; set; }
//        public int Price { get; set; }
//    }

//    // Розглянемо на прикладі
//    class FluentContext : DbContext
//    {
//        public FluentContext() : base("DefaultConnection")
//        { }

//        public DbSet<Phone> Phones { get; set; }

//        protected override void OnModelCreating(DbModelBuilder modelBuilder)
//        {
//            // Використання Fluent API
//            base.OnModelCreating(modelBuilder);
//        }

//        // СПІВСТАВЛЕННЯ КЛАСУ З ТАБЛИЦЕЮ ------------------------------------------------------------------------------------------------------------------------------------------
//        // За замовчуванням EF співставляє модель з однойменною таблицею
//        // Проте ми можемо перевизначити цю поведінку з допомогою метода ToTable

//        protected override void OnModelCreating(DbModelBuilder modelBuilder)
//        {
//            // Тепер всі об'єкти Phone будуть збергіатись в таблиі Mobiles. Проте ми також можемо з ними працювати через властивість db.Phones.
//            modelBuilder.Entity<Phone>().ToTable("Mobiles");
//            base.OnModelCreating(modelBuilder);

//            // Якщо нам не потрібн о створювати таблицю для якоїсть сутності, можна використати метод Ignore()
//            modelBuilder.Ignore<Company>();

//            // ПЕРЕВИЗНАЧЕННЯ ПЕРВИННОГО КЛЮЧА --------------------------------------------------------------------------------------------------------------------------------------
//            // За замовчуванням в Entity Framework первинний ключ повинен представляти властивість моделі з ім'ям Id, тобто назва класу і Id - наприклад PhoneId
//            // Щоб перевизначити первинний ключ через Fluent API, необхідно використовувати метод HasKey()
//            modelBuilder.Entity<Phone>().HasKey(p => p.Ident);
//            // В даному випадку первинним ключем буде властивість Ident класу Phone

//            // Щоб налаштувати складний первинний ключ, можна вказати дві властивості
//            modelBuilder.Entity<Phone>().HasKey(p => new { p.Ident, p.Name });

//            // СПІВСТАВЛЕННЯ ВЛАСТИВОСТЕЙ -----------------------------------------------------------------------------------------------------------------------------------------
//            // Щоб співставити властивість з визначеною колонкою, використовується метод HasColumnName()
//            modelBuilder.Entity<Phone>().Property(p => p.Name).HasColumnName("PhoneName");
//            // В даному випаду властивість Name буде співставлятись з колонкою в таблиці PhoneName

//            // Якщо ми хочемо, щоб якась властивість взагалі не співставлялась з жодною колонкою з таблиці, можемо використати метод Ignore()
//            modelBuilder.Entity<Phone>().Ignore(p => p.Discount);
//            // Тепер властивість Discount класу Phone не буде співставлятись ні з якою колонкою з таблиці в базі даних
//            // Колонки в таблиці і базі даних можуть допускати значення NULL, яке вказує, що значення не визначено.
//            // За замовчуванням всі колонки при Code First, якщо не застосовувати анотаційних даних, за вийнятком ідентифікатора допускаються NULL

//            // Проте ми можемо вказати з допомогою методу IsRequired(). що значення для цієї властивості і відповідної колонки є обов'язковим
//            modelBuilder.Entity<Phone>().Property(p => p.Name).IsRequired();

//            // якщо ж нам навпаки потрібно вказати що колонка може містити NULL, ми можемо використати метод IsOptional()
//            modelBuilder.Entity<Phone>().Property(p => p.Name).IsOptional();

//            // НАЛАШТУВАННЯ РЯДКІВ -------------------------------------------------------------------------------------------------------------------------------------------------
//            // Для налаштування рядків ми моделям вказуємо максимальну довжину з допомогою методу HasMaxLength(), наприклад довжина не більше 90 символів
//            modelBuilder.Entity<Phone>().Property(p => p.Name).HasMaxLength(50);

//            // Також для рядків можна визначити, чи будуть вони зберігатись в кодуванні Unicode
//            modelBuilder.Entity<Phone>().Property(p => p.Name).IsUnicode(false);
//            // В даному випадку параметр false - вказує що такі рядки не будуть зберігатись в форматі кодування Unicode

//            // НАЛАШТУВАННЯ ТИПУ КОЛОНКИ ------------------------------------------------------------------------------------------------------------------------------------------
//            // За замовчуванням EF сам вибирає типи даних в базу даних, виходячи з того який тип даних має відповідна властивість
//            // Проте ми можемо також явно вказати, який тип даних в базі даних слід використовувати для колонки з допомогою методу HasColumnType()
//            modelBuilder.Entity<Phone>().Property(p => p.Name).HasColumnType("varchar");

//            // СПІВСТАВЛЕННЯ МОДЕЛІ З ДЕКІЛЬКОМА ТАБЛИЦЯМИ
//            // З допомогою Fluent API ми можемо помістити ряд властивостей моделі в одну таблицю, а інші властивості звязати з колонками зі другої таблиці
//            modelBuilder.Entity<Phone>().Map(m =>
//            {
//                m.Properties(p => new { p.Ident, p.Name });
//                m.ToTable("Mobiles");
//            })
//            .Map(m =>
//            {
//                m.Properties(p => new { p.Ident, p.Price, p.Discount });
//                m.ToTable("MobilesInfo");
//            });
//            // Таким чином, дані для властивості Name  будуть зберігатись в таблиці Mobiles
//            // а дані для властивості Price і Discount - таблиці MobilesInfo. І колонка ідентифікатора буде спільною
//        }
//    }

//    class Fluen__API
//    {
//    }
//}
